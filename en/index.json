[
{
	"uri": "http://yu-zhang-1985.github.io/en/",
	"title": "",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "http://yu-zhang-1985.github.io/en/posts/",
	"title": "Posts",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "http://yu-zhang-1985.github.io/en/tags/python/",
	"title": "Python",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "http://yu-zhang-1985.github.io/en/tags/",
	"title": "Tags",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "http://yu-zhang-1985.github.io/en/tags/tensorflow2.0/",
	"title": "Tensorflow2.0",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "http://yu-zhang-1985.github.io/en/posts/tensorflow2%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A01/",
	"title": "Tensorflow2深度学习1",
	"tags": ["Python", "Tensorflow2.0"],
	"categories": [],
	"series": [],
	"description": "",
	"content": " Tensorflow2深度学习1 创建已知分布的张量 通过tf.random.normal(shape, mean=0.0, stddev=1.0)可以创建形状为 shape，均值为 mean，标准差为 stddev 的正态分布𝒩(𝑚𝑒𝑎𝑛, 𝑠𝑡𝑑𝑑𝑒𝑣2)。\n例如，创建均值为 0， 标准差为1的正态分布：\n1  tf.random.normal([2, 2])   创建均值为 1，标准差为 2 的正太分布：\n1  tf.random.normal([2,2], mean=1,stddev=2)    通过tf.random.uniform(shape, minval=0, maxval=None, dtype=tf.float32)可以创建采样自 [𝑚𝑖𝑛𝑣𝑎𝑙, 𝑚𝑎𝑥𝑣𝑎𝑙]区间的均匀分布的张量。\n例如创建采样自区间[0,1]， shape 为[2,2]的矩阵:\n1  tf.random.uniform([2,2])    创建序列 在循环计算或者对张量进行索引时，经常需要创建一段连续的整形序列，可以通过tf.range()函数实现。 tf.range(limit, delta=1)可以创建[0, 𝑙𝑖𝑚𝑖𝑡)之间，步长为 delta 的整形序列，不包含 limit 本身。\n例如，创建 0~9，步长为 1 的整形序列\n1  tf.range(10)   Tensorflow 进阶 合并与分割 合并 合并是指将多个张量在某个维度上合并为一个张量。 以某学校班级成绩册数据为例， 设张量 A 保存了某学校 1-4 号班级的成绩册，每个班级 35 个学生，共 8 门科目，则张量 A 的 shape 为： [4,35,8]； 同样的方式，张量 B 保存了剩下的 6 个班级的成绩册， shape 为 [6,35,8]。通过合并 2 个成绩册， 便可得到学校所有班级的成绩册张量 C， shape 应为 [10,35,8]。 这就是张量合并的意义所在。 张量的合并可以使用拼接(Concatenate)和堆叠 (Stack)操作实现，拼接并不会产生新的维度，而堆叠会创建新维度。选择使用拼接还是堆 叠操作来合并张量，取决于具体的场景是否需要创建新维度。\n拼接在TensorFlow 中，可以通过 tf.concat(tensors, axis)，其中 tensors 保存了所有需要 合并的张量 List， axis 指定需要合并的维度。回到上面的例子， 这里班级维度索引号为 0， 即 axis=0， 合并张量 A,B 如下：\n1 2 3 4 5 6 7 8 9 10 11 12  a = tf.random.normal([4, 35, 8]) b = tf.random.normal([6, 35, 8]) tf.concat([a,b],axis=0) \u0026gt;\u0026gt;\u0026gt; \u0026lt;tf.Tensor: id=13, shape=(10, 35, 8), dtype=float32, numpy= array([[[ 8.8570964e-01, 5.4271686e-01, 6.7099530e-01, ..., 1.2183920e+00, 1.6942458e+00, 5.6671137e-01], [ 1.7924213e+00, -2.1710000e-03, -4.6756008e-01, ..., -3.2004917e-01, 8.6718071e-01, 4.4047076e-01], [-5.8158237e-01, 9.7340065e-01, 6.4484423e-01, ..., 2.2783038e-01, -7.4327374e-01, -1.6929630e+00], ...,   合并操作可以在任意的维度上进行，唯一的约束是非合并维度的长度必须一致。 比如 shape 为[4,32,8]和 shape 为[6,35,8]的张量则不能直接在班级维度上进行合并，因为学生数维度的 长度并不一致，一个为 32，另一个为 35。\n堆叠 tf.concat 直接在现有维度上面合并数据， 并不会创建新的维度。 如果在合并数据 时，希望创建一个新的维度，则需要使用 tf.stack 操作。考虑张量 A 保存了某个班级的成 绩册， shape 为[35,8]， 张量 B 保存了另一个班级的成绩册， shape 为[35,8]。合并这 2 个班 级的数据时，需要创建一个新维度，定义为班级维度， 新维度可以选择放置在任意位置， 一般根据大小维度的经验法则，将较大概念的班级维度放置在学生维度之前， 则合并后的 张量的新 shape 应为[2,35,8]\n使用 tf.stack(tensors, axis)可以合并多个张量 tensors，其中 axis 指定插入新维度的位 置， axis 的用法与 tf.expand_dims 的一致，当axis ≥ 0时，在 axis 之前插入;当axis \u0026lt; 0时， 在 axis 之后插入新维度。 例如 shape 为[𝑏, 𝑐, ℎ, 𝑤]的张量，在不同位置通过 stack 操作插入 新维度， axis 参数对应的插入位置设置如下图所示：\n堆叠方式合并这 2 个班级成绩册如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  a = tf.random.normal([35, 8]) b = tf.random.normal([35, 8]) tf.stack([a,b],axis=0) \u0026gt;\u0026gt;\u0026gt; \u0026lt;tf.Tensor: id=12, shape=(2, 35, 8), dtype=float32, numpy= array([[[-2.07745954e-01, -2.20502543e+00, -8.23655784e-01, 5.48114002e-01, -1.88472852e-01, 1.11393249e+00, 5.76643407e-01, 2.46200943e+00], [-1.34531006e-01, -6.47483051e-01, 2.26597333e+00, -1.91579258e+00, -9.96486470e-02, 1.14866197e+00, 6.14816546e-01, 3.88844609e-01], [ 2.80898750e-01, -8.78563046e-01, 3.02676171e-01, -8.55822623e-01, -1.33168280e+00, 4.88721691e-02, -2.57279962e-01, -8.46524596e-01], [-3.17433141e-02, 7.61308789e-01, -6.20268703e-01, -1.77424073e+00, -1.46247709e+00, 1.39056846e-01, -4.85520959e-01, -3.28335166e-01], [ 3.54683638e-01, -9.66821671e-01, 7.51357496e-01, -1.14020419e+00, 1.50615618e-01, -5.70143521e-01, 3.97633016e-01, -4.33588564e-01],...   tf.stack 也需要满足张量堆叠合并条件，它需要所有合并的张量 shape 完全一致才可合并。\n分割 合并操作的逆过程就是分割，将一个张量分拆为多个张量。继续考虑成绩册的例子，我们得到整个学校的成绩册张量， shape 为[10,35,8]，现在需要将数据在班级维度切割为10 个张量，每个张量保存了对应班级的成绩册。 通过 tf.split(x, axis, num_or_size_splits)可以完成张量的分割操作，其中 ❑ x：待分割张量 ❑ axis：分割的维度索引号 ❑ num_or_size_splits：切割方案。当 num_or_size_splits 为单个数值时，如 10，表示切割 为 10 份；当 num_or_size_splits 为 List 时，每个元素表示每份的长度，如[2,4,2,2]表示切割为 4 份，每份的长度分别为 2,4,2,2\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  x = tf.random.normal([10,35,8]) result = tf.split(x,axis=0,num_or_size_splits=10) len(result) \u0026gt;\u0026gt;\u0026gt; 10 result[0] \u0026gt;\u0026gt;\u0026gt; \u0026lt;tf.Tensor: id=8, shape=(1, 35, 8), dtype=float32, numpy= array([[[-0.85184807, 1.3023669 , -0.6299309 , -1.0691075 , 0.89515835, 1.5502766 , 0.73648924, -0.28014854], [-1.1703638 , -1.0702999 , 0.14448726, 0.21638253, -1.0922323 , -0.70183253, 0.7688517 , 0.254894 ], [-0.19054046, -0.94894826, 0.509884 , -0.10021583, -1.8817822 , -0.6811145 , -0.8317199 , -2.0539005 ], [ 0.35156137, -0.1522366 , 0.881225 , 0.41727147, -0.3673428 , 0.28644273, -0.7694335 , 1.9294138 ], [ 0.2886285 , -0.28281617, 2.085483 , 0.6884915 , -0.74251384, -0.04762862, -1.6109419 , 0.3967676 ], [-0.16406545, 1.6274209 , -1.7666724 , -0.13634756, 1.1297457 , -0.51879525, 0.07458926, -0.86752087],...   特别地，如果希望在某个维度上全部按长度为 1 的方式分割，还可以直接使用 tf.unstack(x, axis)。这种方式是 tf.split 的一种特殊情况，切割长度固定为 1，只需要指定切割维度即 可。例如，将总成绩册张量在班级维度进行 unstack：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  x = tf.random.normal([10,35,8]) result = tf.unstack(x,axis=0) len(result) \u0026gt;\u0026gt;\u0026gt; 10 result[0] \u0026gt;\u0026gt;\u0026gt; \u0026lt;tf.Tensor: id=24, shape=(35, 8), dtype=float32, numpy= array([[ 2.3499814e-01, -1.1842293e+00, 1.3272552e+00, 6.4903384e-01, -1.9246280e-01, 1.3754971e+00, 3.4612319e-01, 1.6372271e+00], [ 8.3820176e-01, -1.2983169e-03, 1.5911472e-01, -1.5614045e+00, 1.0038549e+00, 1.5761454e+00, -1.1039929e+00, -9.8006409e-01], [ 1.2048551e-01, -1.2589523e+00, -1.2453424e-02, -1.5870620e+00, 5.9980989e-01, 3.7658808e-01, 1.5330039e+00, -9.3075413e-01], [ 1.2049198e+00, 1.5333800e+00, 2.1740818e-01, 5.0086784e-01, -7.3233676e-01, -1.2100717e+00, 9.9705887e-01, -2.0708323e-01], [ 9.0880913e-01, 3.3859581e-01, -7.3015666e-01, 2.2648830e+00, -2.0122778e+00, 1.6395996e+00, 2.4187420e-01, -1.3059950e-01], [ 2.1328552e+00, -7.8336847e-01, 8.2249206e-01, -1.4364395e+00, 2.9055530e-01, -9.8072761e-01, 9.2565483e-01, -6.2752402e-01], [ 8.4056842e-01, -7.3818415e-02, 4.6472155e-02, 1.5118374e-01, -2.2872338e+00, -1.4693606e-01, -1.3184593e+00, 1.5431756e-01], [-6.4098752e-01, 7.9867637e-01, -1.4770398e-01, 1.2196998e-01, -2.0005221e+00, 8.0921733e-01, 9.0594894e-01, 1.0971487e+00], [-4.4344936e-02, -7.4685121e-01, -1.5849980e+00, 4.7536910e-01, 1.1413414e+00, -1.2368580e+00, 1.6116165e+00, -3.3580515e-01],...   可以看到，通过 tf.unstack 切割后， shape 变为[35,8]，即班级维度消失了，这也是与 tf.split 区别之处。\n数据统计 向量范数 向量范数(Vector norm)是表征向量“长度”的一种度量方法，在神经网络中，常用来 表示张量的权值大小，梯度大小等。常用的向量范数有：\n❑ L1 范数，定义为向量𝒙的所有元素绝对值之和\n$$||x||1=\\sum{i}|x_i|$$\n❑ L2 范数，定义为向量𝒙的所有元素的平方和，再开根号\n$$||x||2=\\sqrt{\\sum{i}|x|^2}$$\n❑ ∞ -范数，定义为向量𝒙的所有元素绝对值的最大值\n$$||x||_\\infty=\\max_i(|x_i|）$$\n对于矩阵、张量，同样可以利用向量范数的计算公式，等价于将矩阵、张量打平成向量后 计算。\n在 TensorFlow 中，可以通过 tf.norm(x, ord)求解张量的 L1, L2, ∞等范数，其中参数 ord 指定为 1,2 时计算 L1, L2 范数，指定为 np.inf 时计算∞ -范数：\n1 2 3 4 5 6 7 8 9 10  x = tf.ones([2,2]) tf.norm(x,ord=1) \u0026gt;\u0026gt;\u0026gt; \u0026lt;tf.Tensor: id=6, shape=(), dtype=float32, numpy=4.0\u0026gt; tf.norm(x,ord=2) \u0026gt;\u0026gt;\u0026gt; \u0026lt;tf.Tensor: id=11, shape=(), dtype=float32, numpy=2.0\u0026gt; tf.norm(x,ord=np.inf) \u0026gt;\u0026gt;\u0026gt; \u0026lt;tf.Tensor: id=15, shape=(), dtype=float32, numpy=1.0\u0026gt;   最大最小值，均值，和 通过 tf.reduce_max, tf.reduce_min, tf.reduce_mean, tf.reduce_sum 可以求解张量在某个维度上的最大、最小、 均值、和，也可以求全局最大、最小、均值、和信息。 考虑 shape 为[4,10]的张量，其中第一个维度代表样本数量，第二个维度代表了当前样本分别属于 10 个类别的概率， 需要求出每个样本的概率最大值为：\n1 2 3 4 5 6 7 8 9 10  x = tf.random.normal([4,10]) tf.reduce_max(x,axis=1) # 统计概率维度上的最大值 \u0026gt;\u0026gt;\u0026gt; \u0026lt;tf.Tensor: id=7, shape=(4,), dtype=float32, numpy=array([1.0590736, 1.9143077, 1.4106003, 1.1981078], dtype=float32)\u0026gt; tf.reduce_min(x,axis=1) # 统计概率维度上的最小值 \u0026gt;\u0026gt;\u0026gt; \u0026lt;tf.Tensor: id=9, shape=(4,), dtype=float32, numpy=array([-1.4143783 , -1.6075196 , -1.0238858 , -0.79297394], dtype=float32)\u0026gt; tf.reduce_mean(x,axis=1) # 统计概率维度上的均值 \u0026gt;\u0026gt;\u0026gt; \u0026lt;tf.Tensor: id=11, shape=(4,), dtype=float32, numpy=array([0.14184079, 0.0247014 , 0.11403179, 0.07959435], dtype=float32)\u0026gt;   当不指定 axis 参数时， tf.reduce_*函数会求解出全局元素的最大、最小、 均值、和：\n1 2 3 4 5 6  x = tf.random.normal([4,10]) tf.reduce_max(x),tf.reduce_min(x),tf.reduce_mean(x) \u0026gt;\u0026gt;\u0026gt; (\u0026lt;tf.Tensor: id=19, shape=(), dtype=float32, numpy=2.8448734\u0026gt;, \u0026lt;tf.Tensor: id=21, shape=(), dtype=float32, numpy=-2.3243723\u0026gt;, \u0026lt;tf.Tensor: id=23, shape=(), dtype=float32, numpy=-0.03267593\u0026gt;)   在求解误差函数时，通过 TensorFlow 的 MSE 误差函数可以求得每个样本的误差，需要计算样本的平均误差，此时可以通过 tf.reduce_mean 在样本数维度上计算均值：\n1 2 3 4 5 6 7 8  out = tf.random.normal([4,10]) y = tf.constant([1,2,2,0]) y = tf.one_hot(y,depth=10) loss = keras.losses.mse(y,out) loss = tf.reduce_mean(loss) loss \u0026gt;\u0026gt;\u0026gt; \u0026lt;tf.Tensor: id=39, shape=(), dtype=float32, numpy=0.8586455\u0026gt;   与均值函数相似的是求和函数 tf.reduce_sum(x,axis)， 它可以求解张量在 axis 轴上所有 特征的和：\n1 2 3 4  out = tf.random.normal([4,10]) tf.reduce_sum(out,axis=-1) \u0026gt;\u0026gt;\u0026gt; \u0026lt;tf.Tensor: id=47, shape=(4,), dtype=float32, numpy=array([-2.6859164, -2.5817413, 4.8744864, 3.4555972], dtype=float32)\u0026gt;   除了希望获取张量的最值信息，还希望获得最值所在的索引号，例如分类任务的标签 预测。考虑 10 分类问题，我们得到神经网络的输出张量 out， shape 为[2,10]， 代表了 2 个 样本属于 10 个类别的概率， 由于元素的位置索引代表了当前样本属于此类别的概率，预测 时往往会选择概率值最大的元素所在的索引号作为样本类别的预测值：\n1 2 3 4 5 6 7 8 9 10  out = tf.random.normal([2,10]) out = tf.nn.softmax(out, axis=1) out \u0026gt;\u0026gt;\u0026gt; \u0026lt;tf.Tensor: id=54, shape=(2, 10), dtype=float32, numpy= array([[0.00528748, 0.02471813, 0.06049791, 0.00718075, 0.00608205, 0.52075624, 0.00456582, 0.00536407, 0.04504047, 0.32050705], [0.0529757 , 0.01163471, 0.06103916, 0.06392826, 0.3175848 , 0.1027843 , 0.14814284, 0.20859584, 0.0232464 , 0.01006791]], dtype=float32)\u0026gt;   以第一个样本为例，可以看到，它概率最大的索引为𝑖 = 5，最大概率值为 0.20859584。由于每个索引号上的概率值代表了样本属于此索引号的类别的概率，因此第一个样本属于 5 类的概率最大，在预测时考虑第一个样本应该最有可能属于类别 5。 这就是需要求解最大值的索引号的一个典型应用。 通过 tf.argmax(x, axis)， tf.argmin(x, axis)可以求解在 axis 轴上， x 的最大值、 最小值所在的索引号:\n1 2 3 4  pred = tf.argmax(out, axis=1) pred \u0026gt;\u0026gt;\u0026gt; \u0026lt;tf.Tensor: id=56, shape=(2,), dtype=int64, numpy=array([5, 4], dtype=int64)\u0026gt;   可以看到，这 2 个样本概率最大值分别出现在索引 5和4 上，因此最有可能分别是类别 5和4，我们将类别 5和4作为这 2 个样本的预测类别。\n"
},
{
	"uri": "http://yu-zhang-1985.github.io/en/posts/python%E5%9F%BA%E7%A1%803/",
	"title": "Python基础3",
	"tags": ["Python"],
	"categories": [],
	"series": [],
	"description": "",
	"content": " 函数式编程 函数是Python内建支持的一种封装，我们通过把大段代码拆成函数，通过一层一层的函数调用，就可以把复杂任务分解成简单的任务，这种分解可以称之为面向过程的程序设计。函数就是面向过程的程序设计的基本单元。\n而函数式编程（请注意多了一个“式”字）——Functional Programming，虽然也可以归结到面向过程的程序设计，但其思想更接近数学计算。\n对应到编程语言，就是越低级的语言，越贴近计算机，抽象程度低，执行效率高，比如C语言；越高级的语言，越贴近计算，抽象程度高，执行效率低，比如Lisp语言。\n函数式编程就是一种抽象程度很高的编程范式，纯粹的函数式编程语言编写的函数没有变量，因此，任意一个函数，只要输入是确定的，输出就是确定的，这种纯函数我们称之为没有副作用。而允许使用变量的程序设计语言，由于函数内部的变量状态不确定，同样的输入，可能得到不同的输出，因此，这种函数是有副作用的。\n函数式编程的一个特点就是，允许把函数本身作为参数传入另一个函数，还允许返回一个函数！\nPython对函数式编程提供部分支持。由于Python允许使用变量，因此，Python不是纯函数式编程语言。\n高阶函数 变量可以指向函数 以Python内置的求绝对值的函数abs()为例，调用该函数用以下代码：\n1 2  \u0026gt;\u0026gt;\u0026gt; abs(-10) 10   但是，如果只写abs呢？\n1 2  \u0026gt;\u0026gt;\u0026gt; abs \u0026lt;built-in function abs\u0026gt;   可见，abs(-10)是函数调用，而abs是函数本身。\n要获得函数调用结果，我们可以把结果赋值给变量：\n1 2 3  \u0026gt;\u0026gt;\u0026gt; x = abs(-10) \u0026gt;\u0026gt;\u0026gt; x 10   但是，如果把函数本身赋值给变量呢？\n1 2 3  \u0026gt;\u0026gt;\u0026gt; f = abs \u0026gt;\u0026gt;\u0026gt; f \u0026lt;built-in function abs\u0026gt;   结论：函数本身也可以赋值给变量，即：变量可以指向函数。\n如果一个变量指向了一个函数，那么，可否通过该变量来调用这个函数？用代码验证一下：\n1 2 3  \u0026gt;\u0026gt;\u0026gt; f = abs \u0026gt;\u0026gt;\u0026gt; f(-10) 10   成功！说明变量f现在已经指向了abs函数本身。直接调用abs()函数和调用变量f()完全相同。\n函数名也是变量 那么函数名是什么呢？函数名其实就是指向函数的变量！对于abs()这个函数，完全可以把函数名abs看成变量，它指向一个可以计算绝对值的函数！\n如果把abs指向其他对象，会有什么情况发生？\n1 2 3 4 5  \u0026gt;\u0026gt;\u0026gt; abs = 10 \u0026gt;\u0026gt;\u0026gt; abs(-10) Traceback (most recent call last): File \u0026#34;\u0026lt;stdin\u0026gt;\u0026#34;, line 1, in \u0026lt;module\u0026gt; TypeError: \u0026#39;int\u0026#39; object is not callable   把abs指向10后，就无法通过abs(-10)调用该函数了！因为abs这个变量已经不指向求绝对值函数而是指向一个整数10！\n当然实际代码绝对不能这么写，这里是为了说明函数名也是变量。要恢复abs函数，请重启Python交互环境。\n注：由于abs函数实际上是定义在import builtins模块中的，所以要让修改abs变量的指向在其它模块也生效，要用import builtins; builtins.abs = 10。\n传入函数 既然变量可以指向函数，函数的参数能接收变量，那么一个函数就可以接收另一个函数作为参数，这种函数就称之为高阶函数。\n一个最简单的高阶函数：\n1 2  def add(x, y, f): return f(x) + f(y)   当我们调用add(-5, 6, abs)时，参数x，y和f分别接收-5，6和abs，根据函数定义，我们可以推导计算过程为：\n1 2 3 4 5  x = -5 y = 6 f = abs f(x) + f(y) ==\u0026gt; abs(-5) + abs(6) ==\u0026gt; 11 return 11   map/reduce Python内建了map()和reduce()函数\nmap()函数接收两个参数，一个是函数，一个是Iterable，map将传入的函数依次作用到序列的每个元素，并把结果作为新的Iterator返回。\n举例说明，比如我们有一个函数f(x)=x^2^，要把这个函数作用在一个list [1, 2, 3, 4, 5, 6, 7, 8, 9]上，就可以用map()实现如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  f(x) = x * x │ │ ┌───┬───┬───┬───┼───┬───┬───┬───┐ │ │ │ │ │ │ │ │ │ ▼ ▼ ▼ ▼ ▼ ▼ ▼ ▼ ▼ [ 1 2 3 4 5 6 7 8 9 ] │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ ▼ ▼ ▼ ▼ ▼ ▼ ▼ ▼ ▼ [ 1 4 9 16 25 36 49 64 81 ]   现在，我们用Python代码实现：\n1 2 3 4 5 6  \u0026gt;\u0026gt;\u0026gt; def f(x): ... return x * x ... \u0026gt;\u0026gt;\u0026gt; r = map(f, [1, 2, 3, 4, 5, 6, 7, 8, 9]) \u0026gt;\u0026gt;\u0026gt; list(r) [1, 4, 9, 16, 25, 36, 49, 64, 81]   map()传入的第一个参数是f，即函数对象本身。由于结果r是一个Iterator，Iterator是惰性序列，因此通过list()函数让它把整个序列都计算出来并返回一个list。\nreduce把一个函数作用在一个序列[x1, x2, x3, ...]上，这个函数必须接收两个参数，reduce把结果继续和序列的下一个元素做累积计算，其效果就是：\n1  reduce(f, [x1, x2, x3, x4]) = f(f(f(x1, x2), x3), x4)   比方说对一个序列求和，就可以用reduce实现：\n1 2 3 4 5 6  \u0026gt;\u0026gt;\u0026gt; from functools import reduce \u0026gt;\u0026gt;\u0026gt; def add(x, y): ... return x + y ... \u0026gt;\u0026gt;\u0026gt; reduce(add, [1, 3, 5, 7, 9]) 25   当然求和运算可以直接用Python内建函数sum()，没必要动用reduce。\n但是如果要把序列[1, 3, 5, 7, 9]变换成整数13579，reduce就可以派上用场：\n1 2 3 4 5 6  \u0026gt;\u0026gt;\u0026gt; from functools import reduce \u0026gt;\u0026gt;\u0026gt; def fn(x, y): ... return x * 10 + y ... \u0026gt;\u0026gt;\u0026gt; reduce(fn, [1, 3, 5, 7, 9]) 13579   这个例子本身没多大用处，但是，如果考虑到字符串str也是一个序列，对上面的例子稍加改动，配合map()，我们就可以写出把str转换为int的函数：\n1 2 3 4 5 6 7 8 9 10  \u0026gt;\u0026gt;\u0026gt; from functools import reduce \u0026gt;\u0026gt;\u0026gt; def fn(x, y): ... return x * 10 + y ... \u0026gt;\u0026gt;\u0026gt; def char2num(s): ... digits = {\u0026#39;0\u0026#39;: 0, \u0026#39;1\u0026#39;: 1, \u0026#39;2\u0026#39;: 2, \u0026#39;3\u0026#39;: 3, \u0026#39;4\u0026#39;: 4, \u0026#39;5\u0026#39;: 5, \u0026#39;6\u0026#39;: 6, \u0026#39;7\u0026#39;: 7, \u0026#39;8\u0026#39;: 8, \u0026#39;9\u0026#39;: 9} ... return digits[s] ... \u0026gt;\u0026gt;\u0026gt; reduce(fn, map(char2num, \u0026#39;13579\u0026#39;)) 13579   整理成一个str2int的函数就是：\n1 2 3 4 5 6 7 8 9 10  from functools import reduce DIGITS = {\u0026#39;0\u0026#39;: 0, \u0026#39;1\u0026#39;: 1, \u0026#39;2\u0026#39;: 2, \u0026#39;3\u0026#39;: 3, \u0026#39;4\u0026#39;: 4, \u0026#39;5\u0026#39;: 5, \u0026#39;6\u0026#39;: 6, \u0026#39;7\u0026#39;: 7, \u0026#39;8\u0026#39;: 8, \u0026#39;9\u0026#39;: 9} def str2int(s): def fn(x, y): return x * 10 + y def char2num(s): return DIGITS[s] return reduce(fn, map(char2num, s))   还可以用lambda函数进一步简化成：\n1 2 3 4 5 6 7 8 9  from functools import reduce DIGITS = {\u0026#39;0\u0026#39;: 0, \u0026#39;1\u0026#39;: 1, \u0026#39;2\u0026#39;: 2, \u0026#39;3\u0026#39;: 3, \u0026#39;4\u0026#39;: 4, \u0026#39;5\u0026#39;: 5, \u0026#39;6\u0026#39;: 6, \u0026#39;7\u0026#39;: 7, \u0026#39;8\u0026#39;: 8, \u0026#39;9\u0026#39;: 9} def char2num(s): return DIGITS[s] def str2int(s): return reduce(lambda x, y: x * 10 + y, map(char2num, s))   也就是说，假设Python没有提供int()函数，你完全可以自己写一个把字符串转化为整数的函数，而且只需要几行代码！\n"
},
{
	"uri": "http://yu-zhang-1985.github.io/en/posts/python%E5%9F%BA%E7%A1%802/",
	"title": "Python基础2",
	"tags": ["Python"],
	"categories": [],
	"series": [],
	"description": "",
	"content": " Python 基础 2 - 2019.12.4 高级特性 切片 取前3个元素，用一行代码就可以完成切片：\n1 2  \u0026gt;\u0026gt;\u0026gt; L[0:3] [\u0026#39;Michael\u0026#39;, \u0026#39;Sarah\u0026#39;, \u0026#39;Tracy\u0026#39;]   L[0:3]表示，从索引0开始取，直到索引3为止，但不包括索引3。即索引0，1，2，正好是3个元素。\n如果第一个索引是0，还可以省略：\n1 2  \u0026gt;\u0026gt;\u0026gt; L[:3] [\u0026#39;Michael\u0026#39;, \u0026#39;Sarah\u0026#39;, \u0026#39;Tracy\u0026#39;]   甚至什么都不写，只写[:]就可以原样复制一个list.\ntuple也是一种list，唯一区别是tuple不可变。因此，tuple也可以用切片操作，只是操作的结果仍是tuple：\n1 2  \u0026gt;\u0026gt;\u0026gt; (0, 1, 2, 3, 4, 5)[:3] (0, 1, 2)   字符串'xxx'也可以看成是一种list，每个元素就是一个字符。因此，字符串也可以用切片操作，只是操作结果仍是字符串：\n1 2 3 4  \u0026gt;\u0026gt;\u0026gt; \u0026#39;ABCDEFG\u0026#39;[:3] \u0026#39;ABC\u0026#39; \u0026gt;\u0026gt;\u0026gt; \u0026#39;ABCDEFG\u0026#39;[::2] \u0026#39;ACEG\u0026#39;   迭代 如果给定一个list或tuple，我们可以通过for循环来遍历这个list或tuple，这种遍历我们称为迭代（Iteration）。\n在Python中，迭代是通过for ... in来完成的：\nPython的for循环抽象程度要高于C的for循环，因为Python的for循环不仅可以用在list或tuple上，还可以作用在其他可迭代对象上。\nlist这种数据类型虽然有下标，但很多其他数据类型是没有下标的，但是，只要是可迭代对象，无论有无下标，都可以迭代，比如dict就可以迭代：\n1 2 3 4 5 6 7  \u0026gt;\u0026gt;\u0026gt; d = {\u0026#39;a\u0026#39;: 1, \u0026#39;b\u0026#39;: 2, \u0026#39;c\u0026#39;: 3} \u0026gt;\u0026gt;\u0026gt; for key in d: ... print(key) ... a c b   因为dict的存储不是按照list的方式顺序排列，所以，迭代出的结果顺序很可能不一样。\n默认情况下，dict迭代的是key。如果要迭代value，可以用for value in d.values()，如果要同时迭代key和value，可以用for k, v in d.items()。\n由于字符串也是可迭代对象，因此，也可以作用于for循环：\n1 2 3 4 5 6  \u0026gt;\u0026gt;\u0026gt; for ch in \u0026#39;ABC\u0026#39;: ... print(ch) ... A B C   所以，当我们使用for循环时，只要作用于一个可迭代对象，for循环就可以正常运行，而我们不太关心该对象究竟是list还是其他数据类型。\n那么，如何判断一个对象是可迭代对象呢？方法是通过collections模块的Iterable类型判断：\n1 2 3 4 5 6 7  \u0026gt;\u0026gt;\u0026gt; from collections import Iterable \u0026gt;\u0026gt;\u0026gt; isinstance(\u0026#39;abc\u0026#39;, Iterable) # str是否可迭代 True \u0026gt;\u0026gt;\u0026gt; isinstance([1,2,3], Iterable) # list是否可迭代 True \u0026gt;\u0026gt;\u0026gt; isinstance(123, Iterable) # 整数是否可迭代 False   列表生成式 列表生成式即List Comprehensions，是Python内置的非常简单却强大的可以用来创建list的生成式。\n举个例子，要生成list [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]可以用list(range(1, 11))：\n1 2  \u0026gt;\u0026gt;\u0026gt; list(range(1, 11)) [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]   但如果要生成[1x1, 2x2, 3x3, ..., 10x10]怎么做？方法一是循环：\n1 2 3 4 5 6  \u0026gt;\u0026gt;\u0026gt; L = [] \u0026gt;\u0026gt;\u0026gt; for x in range(1, 11): ... L.append(x * x) ... \u0026gt;\u0026gt;\u0026gt; L [1, 4, 9, 16, 25, 36, 49, 64, 81, 100]   但是循环太繁琐，而列表生成式则可以用一行语句代替循环生成上面的list：\n1 2  \u0026gt;\u0026gt;\u0026gt; [x * x for x in range(1, 11)] [1, 4, 9, 16, 25, 36, 49, 64, 81, 100]   写列表生成式时，把要生成的元素x * x放到前面，后面跟for循环，就可以把list创建出来，十分有用，多写几次，很快就可以熟悉这种语法。\nfor循环后面还可以加上if判断，这样我们就可以筛选出仅偶数的平方：\n1 2  \u0026gt;\u0026gt;\u0026gt; [x * x for x in range(1, 11) if x % 2 == 0] [4, 16, 36, 64, 100]   还可以使用两层循环，可以生成全排列：\n1 2  \u0026gt;\u0026gt;\u0026gt; [m + n for m in \u0026#39;ABC\u0026#39; for n in \u0026#39;XYZ\u0026#39;] [\u0026#39;AX\u0026#39;, \u0026#39;AY\u0026#39;, \u0026#39;AZ\u0026#39;, \u0026#39;BX\u0026#39;, \u0026#39;BY\u0026#39;, \u0026#39;BZ\u0026#39;, \u0026#39;CX\u0026#39;, \u0026#39;CY\u0026#39;, \u0026#39;CZ\u0026#39;]   三层和三层以上的循环就很少用到了。\n运用列表生成式，可以写出非常简洁的代码。例如，列出当前目录下的所有文件和目录名，可以通过一行代码实现：\n1 2 3  \u0026gt;\u0026gt;\u0026gt; import os # 导入os模块，模块的概念后面讲到 \u0026gt;\u0026gt;\u0026gt; [d for d in os.listdir(\u0026#39;.\u0026#39;)] # os.listdir可以列出文件和目录 [\u0026#39;.emacs.d\u0026#39;, \u0026#39;.ssh\u0026#39;, \u0026#39;.Trash\u0026#39;, \u0026#39;Adlm\u0026#39;, \u0026#39;Applications\u0026#39;, \u0026#39;Desktop\u0026#39;, \u0026#39;Documents\u0026#39;, \u0026#39;Downloads\u0026#39;, \u0026#39;Library\u0026#39;, \u0026#39;Movies\u0026#39;, \u0026#39;Music\u0026#39;, \u0026#39;Pictures\u0026#39;, \u0026#39;Public\u0026#39;, \u0026#39;VirtualBox VMs\u0026#39;, \u0026#39;Workspace\u0026#39;, \u0026#39;XCode\u0026#39;]   for循环其实可以同时使用两个甚至多个变量，比如dict的items()可以同时迭代key和value：\n1 2 3 4 5 6 7  \u0026gt;\u0026gt;\u0026gt; d = {\u0026#39;x\u0026#39;: \u0026#39;A\u0026#39;, \u0026#39;y\u0026#39;: \u0026#39;B\u0026#39;, \u0026#39;z\u0026#39;: \u0026#39;C\u0026#39; } \u0026gt;\u0026gt;\u0026gt; for k, v in d.items(): ... print(k, \u0026#39;=\u0026#39;, v) ... y = B x = A z = C   因此，列表生成式也可以使用两个变量来生成list：\n1 2 3  \u0026gt;\u0026gt;\u0026gt; d = {\u0026#39;x\u0026#39;: \u0026#39;A\u0026#39;, \u0026#39;y\u0026#39;: \u0026#39;B\u0026#39;, \u0026#39;z\u0026#39;: \u0026#39;C\u0026#39; } \u0026gt;\u0026gt;\u0026gt; [k + \u0026#39;=\u0026#39; + v for k, v in d.items()] [\u0026#39;y=B\u0026#39;, \u0026#39;x=A\u0026#39;, \u0026#39;z=C\u0026#39;]   最后把一个list中所有的字符串变成小写：\n1 2 3  \u0026gt;\u0026gt;\u0026gt; L = [\u0026#39;Hello\u0026#39;, \u0026#39;World\u0026#39;, \u0026#39;IBM\u0026#39;, \u0026#39;Apple\u0026#39;] \u0026gt;\u0026gt;\u0026gt; [s.lower() for s in L] [\u0026#39;hello\u0026#39;, \u0026#39;world\u0026#39;, \u0026#39;ibm\u0026#39;, \u0026#39;apple\u0026#39;]   生成器 通过列表生成式，我们可以直接创建一个列表。但是，受到内存限制，列表容量肯定是有限的。而且，创建一个包含100万个元素的列表，不仅占用很大的存储空间，如果我们仅仅需要访问前面几个元素，那后面绝大多数元素占用的空间都白白浪费了。\n所以，如果列表元素可以按照某种算法推算出来，那我们是否可以在循环的过程中不断推算出后续的元素呢？这样就不必创建完整的list，从而节省大量的空间。在Python中，这种一边循环一边计算的机制，称为生成器：generator。\n要创建一个generator，有很多种方法。第一种方法很简单，只要把一个列表生成式的[]改成()，就创建了一个generator：\n1 2 3 4 5 6  \u0026gt;\u0026gt;\u0026gt; L = [x * x for x in range(10)] \u0026gt;\u0026gt;\u0026gt; L [0, 1, 4, 9, 16, 25, 36, 49, 64, 81] \u0026gt;\u0026gt;\u0026gt; g = (x * x for x in range(10)) \u0026gt;\u0026gt;\u0026gt; g \u0026lt;generator object \u0026lt;genexpr\u0026gt; at 0x1022ef630\u0026gt;   创建L和g的区别仅在于最外层的[]和()，L是一个list，而g是一个generator。\n我们可以直接打印出list的每一个元素，但我们怎么打印出generator的每一个元素呢？\n如果要一个一个打印出来，可以通过next()函数获得generator的下一个返回值：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  \u0026gt;\u0026gt;\u0026gt; next(g) 0 \u0026gt;\u0026gt;\u0026gt; next(g) 1 \u0026gt;\u0026gt;\u0026gt; next(g) 4 \u0026gt;\u0026gt;\u0026gt; next(g) 9 \u0026gt;\u0026gt;\u0026gt; next(g) 16 \u0026gt;\u0026gt;\u0026gt; next(g) 25 \u0026gt;\u0026gt;\u0026gt; next(g) 36 \u0026gt;\u0026gt;\u0026gt; next(g) 49 \u0026gt;\u0026gt;\u0026gt; next(g) 64 \u0026gt;\u0026gt;\u0026gt; next(g) 81 \u0026gt;\u0026gt;\u0026gt; next(g) Traceback (most recent call last): File \u0026#34;\u0026lt;stdin\u0026gt;\u0026#34;, line 1, in \u0026lt;module\u0026gt; StopIteration   我们讲过，generator保存的是算法，每次调用next(g)，就计算出g的下一个元素的值，直到计算到最后一个元素，没有更多的元素时，抛出StopIteration的错误。\n当然，上面这种不断调用next(g)实在是太变态了，正确的方法是使用for循环，因为generator也是可迭代对象：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  \u0026gt;\u0026gt;\u0026gt; g = (x * x for x in range(10)) \u0026gt;\u0026gt;\u0026gt; for n in g: ... print(n) ... 0 1 4 9 16 25 36 49 64 81   所以，我们创建了一个generator后，基本上永远不会调用next()，而是通过for循环来迭代它，并且不需要关心StopIteration的错误。\ngenerator非常强大。如果推算的算法比较复杂，用类似列表生成式的for循环无法实现的时候，还可以用函数来实现。\n比如，著名的斐波拉契数列（Fibonacci），除第一个和第二个数外，任意一个数都可由前两个数相加得到：\n1, 1, 2, 3, 5, 8, 13, 21, 34, \u0026hellip;\n斐波拉契数列用列表生成式写不出来，但是，用函数把它打印出来却很容易：\n1 2 3 4 5 6 7  def fib(max): n, a, b = 0, 0, 1 while n \u0026lt; max: print(b) a, b = b, a + b n = n + 1 return \u0026#39;done\u0026#39;   *注意*，赋值语句：\n1  a, b = b, a + b   相当于：\n1 2 3  t = (b, a + b) # t是一个tuple a = t[0] b = t[1]   但不必显式写出临时变量t就可以赋值。\n上面的函数可以输出斐波那契数列的前N个数：\n1 2 3 4 5 6 7 8  \u0026gt;\u0026gt;\u0026gt; fib(6) 1 1 2 3 5 8 \u0026#39;done\u0026#39;   仔细观察，可以看出，fib函数实际上是定义了斐波拉契数列的推算规则，可以从第一个元素开始，推算出后续任意的元素，这种逻辑其实非常类似generator。\n也就是说，上面的函数和generator仅一步之遥。要把fib函数变成generator，只需要把print(b)改为yield b就可以了：\n1 2 3 4 5 6 7  def fib(max): n, a, b = 0, 0, 1 while n \u0026lt; max: yield b a, b = b, a + b n = n + 1 return \u0026#39;done\u0026#39;   这就是定义generator的另一种方法。如果一个函数定义中包含yield关键字，那么这个函数就不再是一个普通函数，而是一个generator：\n1 2 3  \u0026gt;\u0026gt;\u0026gt; f = fib(6) \u0026gt;\u0026gt;\u0026gt; f \u0026lt;generator object fib at 0x104feaaa0\u0026gt;   这里，最难理解的就是generator和函数的执行流程不一样。函数是顺序执行，遇到return语句或者最后一行函数语句就返回。而变成generator的函数，在每次调用next()的时候执行，遇到yield语句返回，再次执行时从上次返回的yield语句处继续执行。\n举个简单的例子，定义一个generator，依次返回数字1，3，5：\n1 2 3 4 5 6 7  def odd(): print(\u0026#39;step 1\u0026#39;) yield 1 print(\u0026#39;step 2\u0026#39;) yield(3) print(\u0026#39;step 3\u0026#39;) yield(5)   调用该generator时，首先要生成一个generator对象，然后用next()函数不断获得下一个返回值：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  \u0026gt;\u0026gt;\u0026gt; o = odd() \u0026gt;\u0026gt;\u0026gt; next(o) step 1 1 \u0026gt;\u0026gt;\u0026gt; next(o) step 2 3 \u0026gt;\u0026gt;\u0026gt; next(o) step 3 5 \u0026gt;\u0026gt;\u0026gt; next(o) Traceback (most recent call last): File \u0026#34;\u0026lt;stdin\u0026gt;\u0026#34;, line 1, in \u0026lt;module\u0026gt; StopIteration   可以看到，odd不是普通函数，而是generator，在执行过程中，遇到yield就中断，下次又继续执行。执行3次yield后，已经没有yield可以执行了，所以，第4次调用next(o)就报错。\n回到fib的例子，我们在循环过程中不断调用yield，就会不断中断。当然要给循环设置一个条件来退出循环，不然就会产生一个无限数列出来。\n同样的，把函数改成generator后，我们基本上从来不会用next()来获取下一个返回值，而是直接使用for循环来迭代：\n1 2 3 4 5 6 7 8 9  \u0026gt;\u0026gt;\u0026gt; for n in fib(6): ... print(n) ... 1 1 2 3 5 8   但是用for循环调用generator时，发现拿不到generator的return语句的返回值。如果想要拿到返回值，必须捕获StopIteration错误，返回值包含在StopIteration的value中：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  \u0026gt;\u0026gt;\u0026gt; g = fib(6) \u0026gt;\u0026gt;\u0026gt; while True: ... try: ... x = next(g) ... print(\u0026#39;g:\u0026#39;, x) ... except StopIteration as e: ... print(\u0026#39;Generator return value:\u0026#39;, e.value) ... break ... g: 1 g: 1 g: 2 g: 3 g: 5 g: 8 Generator return value: done   迭代器 我们已经知道，可以直接作用于for循环的数据类型有以下几种：\n一类是集合数据类型，如list、tuple、dict、set、str等；\n一类是generator，包括生成器和带yield的generator function。\n这些可以直接作用于for循环的对象统称为可迭代对象：Iterable。\n可以使用isinstance()判断一个对象是否是Iterable对象：\n1 2 3 4 5 6 7 8 9 10 11  \u0026gt;\u0026gt;\u0026gt; from collections import Iterable \u0026gt;\u0026gt;\u0026gt; isinstance([], Iterable) True \u0026gt;\u0026gt;\u0026gt; isinstance({}, Iterable) True \u0026gt;\u0026gt;\u0026gt; isinstance(\u0026#39;abc\u0026#39;, Iterable) True \u0026gt;\u0026gt;\u0026gt; isinstance((x for x in range(10)), Iterable) True \u0026gt;\u0026gt;\u0026gt; isinstance(100, Iterable) False   而生成器不但可以作用于for循环，还可以被next()函数不断调用并返回下一个值，直到最后抛出StopIteration错误表示无法继续返回下一个值了。\n可以被next()函数调用并不断返回下一个值的对象称为迭代器：Iterator。\n可以使用isinstance()判断一个对象是否是Iterator对象：\n1 2 3 4 5 6 7 8 9  \u0026gt;\u0026gt;\u0026gt; from collections import Iterator \u0026gt;\u0026gt;\u0026gt; isinstance((x for x in range(10)), Iterator) True \u0026gt;\u0026gt;\u0026gt; isinstance([], Iterator) False \u0026gt;\u0026gt;\u0026gt; isinstance({}, Iterator) False \u0026gt;\u0026gt;\u0026gt; isinstance(\u0026#39;abc\u0026#39;, Iterator) False   生成器都是Iterator对象，但list、dict、str虽然是Iterable，却不是Iterator。\n把list、dict、str等Iterable变成Iterator可以使用iter()函数：\n1 2 3 4  \u0026gt;\u0026gt;\u0026gt; isinstance(iter([]), Iterator) True \u0026gt;\u0026gt;\u0026gt; isinstance(iter(\u0026#39;abc\u0026#39;), Iterator) True   你可能会问，为什么list、dict、str等数据类型不是Iterator？\n这是因为Python的Iterator对象表示的是一个数据流，Iterator对象可以被next()函数调用并不断返回下一个数据，直到没有数据时抛出StopIteration错误。可以把这个数据流看做是一个有序序列，但我们却不能提前知道序列的长度，只能不断通过next()函数实现按需计算下一个数据，所以Iterator的计算是惰性的，只有在需要返回下一个数据时它才会计算。\nIterator甚至可以表示一个无限大的数据流，例如全体自然数。而使用list是永远不可能存储全体自然数的。\n"
},
{
	"uri": "http://yu-zhang-1985.github.io/en/posts/python%E5%9F%BA%E7%A1%801/",
	"title": "Python基础1",
	"tags": ["Python"],
	"categories": [],
	"series": [],
	"description": "",
	"content": " Python 基础1 - 2019.12.3 Coding 1  # -*- coding:utf-8 -*-   告诉python解释器，按照UTF-8编码读取源代码\nDict  dict的key必须是不可变对象。  这是因为dict根据key来计算value的存储位置，如果每次计算相同的key得出的结果不同，那dict内部就完全混乱了。这个通过key计算位置的算法称为哈希算法（Hash）。\n要保证hash的正确性，作为key的对象就不能变。在Python中，字符串、整数等都是不可变的，因此，可以放心地作为key。而list是可变的，就不能作为key。\nSet  set和dict类似，也是一组key的集合，但不存储value。由于key不能重复，所以，在set中，没有重复的key。  要创建一个set，需要提供一个list作为输入集合：\n1 2 3  \u0026gt;\u0026gt;\u0026gt; s = set([1, 2, 3]) \u0026gt;\u0026gt;\u0026gt; s {1, 2, 3}    通过add(key)方法可以添加元素到set中，可以重复添加，但不会有效果.\n 通过remove(key)方法可以删除元素.\n set和dict的唯一区别仅在于没有存储对应的value，但是，set的原理和dict一样，所以，同样不可以放入可变对象，因为无法判断两个可变对象是否相等，也就无法保证set内部“不会有重复元素”。\n  不可变对象  对于不变对象来说，调用对象自身的任意方法，也不会改变该对象自身的内容。相反，这些方法会创建新的对象并返回，这样，就保证了不可变对象本身永远是不可变的  函数  可以直接从Python的官方网站查看文档：http://docs.python.org/3/library/functions.html#abs  也可以在交互式命令行通过help(abs)查看abs函数的帮助信息。\n 在Python中，定义一个函数要使用def语句，依次写出函数名、括号、括号中的参数和冒号:，然后，在缩进块中编写函数体，函数的返回值用return语句返回。 Python的函数返回多值其实就是返回一个tuple。\n 定义默认参数要牢记一点：默认参数必须指向不变对象！\n  为什么要设计str、None这样的不变对象呢？因为不变对象一旦创建，对象内部的数据就不能修改，这样就减少了由于修改数据导致的错误。此外，由于对象不变，多任务环境下同时读取对象不需要加锁，同时读一点问题都没有。我们在编写程序时，如果可以设计一个不变对象，那就尽量设计成不变对象。\n Python允许你在list或tuple前面加一个*号，把list或tuple的元素变成可变参数传进去：\n1 2 3  \u0026gt;\u0026gt;\u0026gt; nums = [1, 2, 3] \u0026gt;\u0026gt;\u0026gt; calc(*nums) 14   关键字参数\n  可变参数允许你传入0个或任意个参数，这些可变参数在函数调用时自动组装为一个tuple。而关键字参数允许你传入0个或任意个含参数名的参数，这些关键字参数在函数内部自动组装为一个dict。请看示例：\n1 2  def person(name, age, **kw): print(\u0026#39;name:\u0026#39;, name, \u0026#39;age:\u0026#39;, age, \u0026#39;other:\u0026#39;, kw)   和可变参数类似，也可以先组装出一个dict，然后，把该dict转换为关键字参数传进去：\n1 2 3  \u0026gt;\u0026gt;\u0026gt; extra = {\u0026#39;city\u0026#39;: \u0026#39;Beijing\u0026#39;, \u0026#39;job\u0026#39;: \u0026#39;Engineer\u0026#39;} \u0026gt;\u0026gt;\u0026gt; person(\u0026#39;Jack\u0026#39;, 24, city=extra[\u0026#39;city\u0026#39;], job=extra[\u0026#39;job\u0026#39;]) name: Jack age: 24 other: {\u0026#39;city\u0026#39;: \u0026#39;Beijing\u0026#39;, \u0026#39;job\u0026#39;: \u0026#39;Engineer\u0026#39;}   当然，上面复杂的调用可以用简化的写法：\n1 2 3  \u0026gt;\u0026gt;\u0026gt; extra = {\u0026#39;city\u0026#39;: \u0026#39;Beijing\u0026#39;, \u0026#39;job\u0026#39;: \u0026#39;Engineer\u0026#39;} \u0026gt;\u0026gt;\u0026gt; person(\u0026#39;Jack\u0026#39;, 24, **extra) name: Jack age: 24 other: {\u0026#39;city\u0026#39;: \u0026#39;Beijing\u0026#39;, \u0026#39;job\u0026#39;: \u0026#39;Engineer\u0026#39;}   **extra表示把extra这个dict的所有key-value用关键字参数传入到函数的**kw参数，kw将获得一个dict，注意kw获得的dict是extra的一份拷贝，对kw的改动不会影响到函数外的extra。\n 如果要限制关键字参数的名字，就可以用命名关键字参数，例如，只接收city和job作为关键字参数。这种方式定义的函数如下：\n1 2  def person(name, age, *, city, job): print(name, age, city, job)    和关键字参数**kw不同，命名关键字参数需要一个特殊分隔符*，*后面的参数被视为命名关键字参数。\n调用方式如下：\n1 2  \u0026gt;\u0026gt;\u0026gt; person(\u0026#39;Jack\u0026#39;, 24, city=\u0026#39;Beijing\u0026#39;, job=\u0026#39;Engineer\u0026#39;) Jack 24 Beijing Engineer   如果函数定义中已经有了一个可变参数，后面跟着的命名关键字参数就不再需要一个特殊分隔符*了：\n1 2  def person(name, age, *args, city, job): print(name, age, args, city, job)   命名关键字参数必须传入参数名，这和位置参数不同。如果没有传入参数名，调用将报错：\n1 2 3 4  \u0026gt;\u0026gt;\u0026gt; person(\u0026#39;Jack\u0026#39;, 24, \u0026#39;Beijing\u0026#39;, \u0026#39;Engineer\u0026#39;) Traceback (most recent call last): File \u0026#34;\u0026lt;stdin\u0026gt;\u0026#34;, line 1, in \u0026lt;module\u0026gt; TypeError: person() takes 2 positional arguments but 4 were given   由于调用时缺少参数名city和job，Python解释器把这4个参数均视为位置参数，但person()函数仅接受2个位置参数。\n命名关键字参数可以有缺省值，从而简化调用：\n1 2  def person(name, age, *, city=\u0026#39;Beijing\u0026#39;, job): print(name, age, city, job)   由于命名关键字参数city具有默认值，调用时，可不传入city参数：\n1 2  \u0026gt;\u0026gt;\u0026gt; person(\u0026#39;Jack\u0026#39;, 24, job=\u0026#39;Engineer\u0026#39;) Jack 24 Beijing Engineer   使用命名关键字参数时，要特别注意，如果没有可变参数，就必须加一个*作为特殊分隔符。如果缺少*，Python解释器将无法识别位置参数和命名关键字参数：\n1 2 3  def person(name, age, city, job): # 缺少 *，city和job被视为位置参数 pass    参数组合  在Python中定义函数，可以用必选参数、默认参数、可变参数、关键字参数和命名关键字参数，这5种参数都可以组合使用。但是请注意，参数定义的顺序必须是：必选参数、默认参数、可变参数、命名关键字参数和关键字参数。\n比如定义一个函数，包含上述若干种参数：\n1 2 3 4 5  def f1(a, b, c=0, *args, **kw): print(\u0026#39;a =\u0026#39;, a, \u0026#39;b =\u0026#39;, b, \u0026#39;c =\u0026#39;, c, \u0026#39;args =\u0026#39;, args, \u0026#39;kw =\u0026#39;, kw) def f2(a, b, c=0, *, d, **kw): print(\u0026#39;a =\u0026#39;, a, \u0026#39;b =\u0026#39;, b, \u0026#39;c =\u0026#39;, c, \u0026#39;d =\u0026#39;, d, \u0026#39;kw =\u0026#39;, kw)   对于任意函数，都可以通过类似func(*args, **kw)的形式调用它，无论它的参数是如何定义的。\n虽然可以组合多达5种参数，但不要同时使用太多的组合，否则函数接口的可理解性很差。\n 递归函数  在函数内部，可以调用其他函数。如果一个函数在内部调用自身本身，这个函数就是递归函数。\n举个例子，我们来计算阶乘n! = 1 x 2 x 3 x ... x n，用函数fact(n)表示，可以看出：\nfact(n) = n! = 1 x 2 x 3 x \u0026hellip; x (n-1) x n = (n-1)! x n = fact(n-1) x n\n所以，fact(n)可以表示为n x fact(n-1)，只有n=1时需要特殊处理。\n于是，fact(n)用递归的方式写出来就是：\n1 2 3 4  def fact(n): if n==1: return 1 return n * fact(n - 1)   上面就是一个递归函数。\n递归函数的优点是定义简单，逻辑清晰。理论上，所有的递归函数都可以写成循环的方式，但循环的逻辑不如递归清晰。\n使用递归函数需要注意防止栈溢出。在计算机中，函数调用是通过栈（stack）这种数据结构实现的，每当进入一个函数调用，栈就会加一层栈帧，每当函数返回，栈就会减一层栈帧。由于栈的大小不是无限的，所以，递归调用的次数过多，会导致栈溢出。\n尾递归是指，在函数返回的时候，调用自身本身，并且，return语句不能包含表达式。这样，编译器或者解释器就可以把尾递归做优化，使递归本身无论调用多少次，都只占用一个栈帧，不会出现栈溢出的情况。\n上面的fact(n)函数由于return n * fact(n - 1)引入了乘法表达式，所以就不是尾递归了。要改成尾递归方式，需要多一点代码，主要是要把每一步的乘积传入到递归函数中：\n1 2 3 4 5 6 7  def fact(n): return fact_iter(n, 1) def fact_iter(num, product): if num == 1: return product return fact_iter(num - 1, num * product)   可以看到，return fact_iter(num - 1, num * product)仅返回递归函数本身，num - 1和num * product在函数调用前就会被计算，不影响函数调用。\n"
},
{
	"uri": "http://yu-zhang-1985.github.io/en/categories/",
	"title": "Categories",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "http://yu-zhang-1985.github.io/en/gallery/",
	"title": "Galleries",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "http://yu-zhang-1985.github.io/en/gallery/mygallery/",
	"title": "Gallery",
	"tags": [""],
	"categories": [],
	"series": [""],
	"description": "",
	"content": ""
},
{
	"uri": "http://yu-zhang-1985.github.io/en/series/",
	"title": "Series",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
}]