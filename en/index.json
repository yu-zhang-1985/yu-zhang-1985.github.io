[
{
	"uri": "http://yu-zhang-1985.github.io/en/",
	"title": "Hugo Zzo Theme",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "http://yu-zhang-1985.github.io/en/post/",
	"title": "Posts",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "http://yu-zhang-1985.github.io/en/tags/python/",
	"title": "Python",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "http://yu-zhang-1985.github.io/en/post/python%E5%AD%A6%E4%B9%A01/",
	"title": "Python学习1",
	"tags": ["Python"],
	"categories": [],
	"series": [],
	"description": "",
	"content": " Python 学习 1 Coding 1  # -*- coding:utf-8 -*-   告诉python解释器，按照UTF-8编码读取源代码\nDict  dict的key必须是不可变对象。  这是因为dict根据key来计算value的存储位置，如果每次计算相同的key得出的结果不同，那dict内部就完全混乱了。这个通过key计算位置的算法称为哈希算法（Hash）。\n要保证hash的正确性，作为key的对象就不能变。在Python中，字符串、整数等都是不可变的，因此，可以放心地作为key。而list是可变的，就不能作为key。\nSet  set和dict类似，也是一组key的集合，但不存储value。由于key不能重复，所以，在set中，没有重复的key。  要创建一个set，需要提供一个list作为输入集合：\n1 2 3  \u0026gt;\u0026gt;\u0026gt; s = set([1, 2, 3]) \u0026gt;\u0026gt;\u0026gt; s {1, 2, 3}    通过add(key)方法可以添加元素到set中，可以重复添加，但不会有效果.\n 通过remove(key)方法可以删除元素.\n set和dict的唯一区别仅在于没有存储对应的value，但是，set的原理和dict一样，所以，同样不可以放入可变对象，因为无法判断两个可变对象是否相等，也就无法保证set内部“不会有重复元素”。\n  不可变对象  对于不变对象来说，调用对象自身的任意方法，也不会改变该对象自身的内容。相反，这些方法会创建新的对象并返回，这样，就保证了不可变对象本身永远是不可变的  函数  可以直接从Python的官方网站查看文档：http://docs.python.org/3/library/functions.html#abs  也可以在交互式命令行通过help(abs)查看abs函数的帮助信息。\n 在Python中，定义一个函数要使用def语句，依次写出函数名、括号、括号中的参数和冒号:，然后，在缩进块中编写函数体，函数的返回值用return语句返回。 Python的函数返回多值其实就是返回一个tuple。\n 定义默认参数要牢记一点：默认参数必须指向不变对象！\n  为什么要设计str、None这样的不变对象呢？因为不变对象一旦创建，对象内部的数据就不能修改，这样就减少了由于修改数据导致的错误。此外，由于对象不变，多任务环境下同时读取对象不需要加锁，同时读一点问题都没有。我们在编写程序时，如果可以设计一个不变对象，那就尽量设计成不变对象。\n Python允许你在list或tuple前面加一个*号，把list或tuple的元素变成可变参数传进去：\n1 2 3  \u0026gt;\u0026gt;\u0026gt; nums = [1, 2, 3] \u0026gt;\u0026gt;\u0026gt; calc(*nums) 14   关键字参数\n  可变参数允许你传入0个或任意个参数，这些可变参数在函数调用时自动组装为一个tuple。而关键字参数允许你传入0个或任意个含参数名的参数，这些关键字参数在函数内部自动组装为一个dict。请看示例：\n1 2  def person(name, age, **kw): print(\u0026#39;name:\u0026#39;, name, \u0026#39;age:\u0026#39;, age, \u0026#39;other:\u0026#39;, kw)   和可变参数类似，也可以先组装出一个dict，然后，把该dict转换为关键字参数传进去：\n1 2 3  \u0026gt;\u0026gt;\u0026gt; extra = {\u0026#39;city\u0026#39;: \u0026#39;Beijing\u0026#39;, \u0026#39;job\u0026#39;: \u0026#39;Engineer\u0026#39;} \u0026gt;\u0026gt;\u0026gt; person(\u0026#39;Jack\u0026#39;, 24, city=extra[\u0026#39;city\u0026#39;], job=extra[\u0026#39;job\u0026#39;]) name: Jack age: 24 other: {\u0026#39;city\u0026#39;: \u0026#39;Beijing\u0026#39;, \u0026#39;job\u0026#39;: \u0026#39;Engineer\u0026#39;}   当然，上面复杂的调用可以用简化的写法：\n1 2 3  \u0026gt;\u0026gt;\u0026gt; extra = {\u0026#39;city\u0026#39;: \u0026#39;Beijing\u0026#39;, \u0026#39;job\u0026#39;: \u0026#39;Engineer\u0026#39;} \u0026gt;\u0026gt;\u0026gt; person(\u0026#39;Jack\u0026#39;, 24, **extra) name: Jack age: 24 other: {\u0026#39;city\u0026#39;: \u0026#39;Beijing\u0026#39;, \u0026#39;job\u0026#39;: \u0026#39;Engineer\u0026#39;}   **extra表示把extra这个dict的所有key-value用关键字参数传入到函数的**kw参数，kw将获得一个dict，注意kw获得的dict是extra的一份拷贝，对kw的改动不会影响到函数外的extra。\n 如果要限制关键字参数的名字，就可以用命名关键字参数，例如，只接收city和job作为关键字参数。这种方式定义的函数如下：\n1 2  def person(name, age, *, city, job): print(name, age, city, job)    和关键字参数**kw不同，命名关键字参数需要一个特殊分隔符*，*后面的参数被视为命名关键字参数。\n调用方式如下：\n1 2  \u0026gt;\u0026gt;\u0026gt; person(\u0026#39;Jack\u0026#39;, 24, city=\u0026#39;Beijing\u0026#39;, job=\u0026#39;Engineer\u0026#39;) Jack 24 Beijing Engineer   如果函数定义中已经有了一个可变参数，后面跟着的命名关键字参数就不再需要一个特殊分隔符*了：\n1 2  def person(name, age, *args, city, job): print(name, age, args, city, job)   命名关键字参数必须传入参数名，这和位置参数不同。如果没有传入参数名，调用将报错：\n1 2 3 4  \u0026gt;\u0026gt;\u0026gt; person(\u0026#39;Jack\u0026#39;, 24, \u0026#39;Beijing\u0026#39;, \u0026#39;Engineer\u0026#39;) Traceback (most recent call last): File \u0026#34;\u0026lt;stdin\u0026gt;\u0026#34;, line 1, in \u0026lt;module\u0026gt; TypeError: person() takes 2 positional arguments but 4 were given   由于调用时缺少参数名city和job，Python解释器把这4个参数均视为位置参数，但person()函数仅接受2个位置参数。\n命名关键字参数可以有缺省值，从而简化调用：\n1 2  def person(name, age, *, city=\u0026#39;Beijing\u0026#39;, job): print(name, age, city, job)   由于命名关键字参数city具有默认值，调用时，可不传入city参数：\n1 2  \u0026gt;\u0026gt;\u0026gt; person(\u0026#39;Jack\u0026#39;, 24, job=\u0026#39;Engineer\u0026#39;) Jack 24 Beijing Engineer   使用命名关键字参数时，要特别注意，如果没有可变参数，就必须加一个*作为特殊分隔符。如果缺少*，Python解释器将无法识别位置参数和命名关键字参数：\n1 2 3  def person(name, age, city, job): # 缺少 *，city和job被视为位置参数 pass    参数组合  在Python中定义函数，可以用必选参数、默认参数、可变参数、关键字参数和命名关键字参数，这5种参数都可以组合使用。但是请注意，参数定义的顺序必须是：必选参数、默认参数、可变参数、命名关键字参数和关键字参数。\n比如定义一个函数，包含上述若干种参数：\n1 2 3 4 5  def f1(a, b, c=0, *args, **kw): print(\u0026#39;a =\u0026#39;, a, \u0026#39;b =\u0026#39;, b, \u0026#39;c =\u0026#39;, c, \u0026#39;args =\u0026#39;, args, \u0026#39;kw =\u0026#39;, kw) def f2(a, b, c=0, *, d, **kw): print(\u0026#39;a =\u0026#39;, a, \u0026#39;b =\u0026#39;, b, \u0026#39;c =\u0026#39;, c, \u0026#39;d =\u0026#39;, d, \u0026#39;kw =\u0026#39;, kw)   对于任意函数，都可以通过类似func(*args, **kw)的形式调用它，无论它的参数是如何定义的。\n虽然可以组合多达5种参数，但不要同时使用太多的组合，否则函数接口的可理解性很差。\n 递归函数  在函数内部，可以调用其他函数。如果一个函数在内部调用自身本身，这个函数就是递归函数。\n举个例子，我们来计算阶乘n! = 1 x 2 x 3 x ... x n，用函数fact(n)表示，可以看出：\nfact(n) = n! = 1 x 2 x 3 x \u0026hellip; x (n-1) x n = (n-1)! x n = fact(n-1) x n\n所以，fact(n)可以表示为n x fact(n-1)，只有n=1时需要特殊处理。\n于是，fact(n)用递归的方式写出来就是：\n1 2 3 4  def fact(n): if n==1: return 1 return n * fact(n - 1)   上面就是一个递归函数。\n递归函数的优点是定义简单，逻辑清晰。理论上，所有的递归函数都可以写成循环的方式，但循环的逻辑不如递归清晰。\n使用递归函数需要注意防止栈溢出。在计算机中，函数调用是通过栈（stack）这种数据结构实现的，每当进入一个函数调用，栈就会加一层栈帧，每当函数返回，栈就会减一层栈帧。由于栈的大小不是无限的，所以，递归调用的次数过多，会导致栈溢出。\n尾递归是指，在函数返回的时候，调用自身本身，并且，return语句不能包含表达式。这样，编译器或者解释器就可以把尾递归做优化，使递归本身无论调用多少次，都只占用一个栈帧，不会出现栈溢出的情况。\n上面的fact(n)函数由于return n * fact(n - 1)引入了乘法表达式，所以就不是尾递归了。要改成尾递归方式，需要多一点代码，主要是要把每一步的乘积传入到递归函数中：\n1 2 3 4 5 6 7  def fact(n): return fact_iter(n, 1) def fact_iter(num, product): if num == 1: return product return fact_iter(num - 1, num * product)   可以看到，return fact_iter(num - 1, num * product)仅返回递归函数本身，num - 1和num * product在函数调用前就会被计算，不影响函数调用。\n"
},
{
	"uri": "http://yu-zhang-1985.github.io/en/tags/",
	"title": "Tags",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "http://yu-zhang-1985.github.io/en/categories/",
	"title": "Categories",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "http://yu-zhang-1985.github.io/en/gallery/",
	"title": "Galleries",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "http://yu-zhang-1985.github.io/en/gallery/mygallery/",
	"title": "Gallery",
	"tags": [""],
	"categories": [],
	"series": [""],
	"description": "",
	"content": ""
},
{
	"uri": "http://yu-zhang-1985.github.io/en/series/",
	"title": "Series",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
}]