[
{
	"uri": "http://yu-zhang-1985.github.io/en/",
	"title": "",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "http://yu-zhang-1985.github.io/en/posts/",
	"title": "Posts",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "http://yu-zhang-1985.github.io/en/tags/python/",
	"title": "Python",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "http://yu-zhang-1985.github.io/en/posts/python%E5%AD%A6%E4%B9%A02/",
	"title": "Python学习2",
	"tags": ["Python"],
	"categories": [],
	"series": [],
	"description": "",
	"content": " Python 学习 2 - 2019.12.4 高级特性 切片 取前3个元素，用一行代码就可以完成切片：\n1 2  \u0026gt;\u0026gt;\u0026gt; L[0:3] [\u0026#39;Michael\u0026#39;, \u0026#39;Sarah\u0026#39;, \u0026#39;Tracy\u0026#39;]   L[0:3]表示，从索引0开始取，直到索引3为止，但不包括索引3。即索引0，1，2，正好是3个元素。\n如果第一个索引是0，还可以省略：\n1 2  \u0026gt;\u0026gt;\u0026gt; L[:3] [\u0026#39;Michael\u0026#39;, \u0026#39;Sarah\u0026#39;, \u0026#39;Tracy\u0026#39;]   甚至什么都不写，只写[:]就可以原样复制一个list.\ntuple也是一种list，唯一区别是tuple不可变。因此，tuple也可以用切片操作，只是操作的结果仍是tuple：\n1 2  \u0026gt;\u0026gt;\u0026gt; (0, 1, 2, 3, 4, 5)[:3] (0, 1, 2)   字符串'xxx'也可以看成是一种list，每个元素就是一个字符。因此，字符串也可以用切片操作，只是操作结果仍是字符串：\n1 2 3 4  \u0026gt;\u0026gt;\u0026gt; \u0026#39;ABCDEFG\u0026#39;[:3] \u0026#39;ABC\u0026#39; \u0026gt;\u0026gt;\u0026gt; \u0026#39;ABCDEFG\u0026#39;[::2] \u0026#39;ACEG\u0026#39;   迭代 如果给定一个list或tuple，我们可以通过for循环来遍历这个list或tuple，这种遍历我们称为迭代（Iteration）。\n在Python中，迭代是通过for ... in来完成的：\nPython的for循环抽象程度要高于C的for循环，因为Python的for循环不仅可以用在list或tuple上，还可以作用在其他可迭代对象上。\nlist这种数据类型虽然有下标，但很多其他数据类型是没有下标的，但是，只要是可迭代对象，无论有无下标，都可以迭代，比如dict就可以迭代：\n1 2 3 4 5 6 7  \u0026gt;\u0026gt;\u0026gt; d = {\u0026#39;a\u0026#39;: 1, \u0026#39;b\u0026#39;: 2, \u0026#39;c\u0026#39;: 3} \u0026gt;\u0026gt;\u0026gt; for key in d: ... print(key) ... a c b   因为dict的存储不是按照list的方式顺序排列，所以，迭代出的结果顺序很可能不一样。\n默认情况下，dict迭代的是key。如果要迭代value，可以用for value in d.values()，如果要同时迭代key和value，可以用for k, v in d.items()。\n由于字符串也是可迭代对象，因此，也可以作用于for循环：\n1 2 3 4 5 6  \u0026gt;\u0026gt;\u0026gt; for ch in \u0026#39;ABC\u0026#39;: ... print(ch) ... A B C   所以，当我们使用for循环时，只要作用于一个可迭代对象，for循环就可以正常运行，而我们不太关心该对象究竟是list还是其他数据类型。\n那么，如何判断一个对象是可迭代对象呢？方法是通过collections模块的Iterable类型判断：\n1 2 3 4 5 6 7  \u0026gt;\u0026gt;\u0026gt; from collections import Iterable \u0026gt;\u0026gt;\u0026gt; isinstance(\u0026#39;abc\u0026#39;, Iterable) # str是否可迭代 True \u0026gt;\u0026gt;\u0026gt; isinstance([1,2,3], Iterable) # list是否可迭代 True \u0026gt;\u0026gt;\u0026gt; isinstance(123, Iterable) # 整数是否可迭代 False   列表生成式 列表生成式即List Comprehensions，是Python内置的非常简单却强大的可以用来创建list的生成式。\n举个例子，要生成list [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]可以用list(range(1, 11))：\n1 2  \u0026gt;\u0026gt;\u0026gt; list(range(1, 11)) [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]   但如果要生成[1x1, 2x2, 3x3, ..., 10x10]怎么做？方法一是循环：\n1 2 3 4 5 6  \u0026gt;\u0026gt;\u0026gt; L = [] \u0026gt;\u0026gt;\u0026gt; for x in range(1, 11): ... L.append(x * x) ... \u0026gt;\u0026gt;\u0026gt; L [1, 4, 9, 16, 25, 36, 49, 64, 81, 100]   但是循环太繁琐，而列表生成式则可以用一行语句代替循环生成上面的list：\n1 2  \u0026gt;\u0026gt;\u0026gt; [x * x for x in range(1, 11)] [1, 4, 9, 16, 25, 36, 49, 64, 81, 100]   写列表生成式时，把要生成的元素x * x放到前面，后面跟for循环，就可以把list创建出来，十分有用，多写几次，很快就可以熟悉这种语法。\nfor循环后面还可以加上if判断，这样我们就可以筛选出仅偶数的平方：\n1 2  \u0026gt;\u0026gt;\u0026gt; [x * x for x in range(1, 11) if x % 2 == 0] [4, 16, 36, 64, 100]   还可以使用两层循环，可以生成全排列：\n1 2  \u0026gt;\u0026gt;\u0026gt; [m + n for m in \u0026#39;ABC\u0026#39; for n in \u0026#39;XYZ\u0026#39;] [\u0026#39;AX\u0026#39;, \u0026#39;AY\u0026#39;, \u0026#39;AZ\u0026#39;, \u0026#39;BX\u0026#39;, \u0026#39;BY\u0026#39;, \u0026#39;BZ\u0026#39;, \u0026#39;CX\u0026#39;, \u0026#39;CY\u0026#39;, \u0026#39;CZ\u0026#39;]   三层和三层以上的循环就很少用到了。\n运用列表生成式，可以写出非常简洁的代码。例如，列出当前目录下的所有文件和目录名，可以通过一行代码实现：\n1 2 3  \u0026gt;\u0026gt;\u0026gt; import os # 导入os模块，模块的概念后面讲到 \u0026gt;\u0026gt;\u0026gt; [d for d in os.listdir(\u0026#39;.\u0026#39;)] # os.listdir可以列出文件和目录 [\u0026#39;.emacs.d\u0026#39;, \u0026#39;.ssh\u0026#39;, \u0026#39;.Trash\u0026#39;, \u0026#39;Adlm\u0026#39;, \u0026#39;Applications\u0026#39;, \u0026#39;Desktop\u0026#39;, \u0026#39;Documents\u0026#39;, \u0026#39;Downloads\u0026#39;, \u0026#39;Library\u0026#39;, \u0026#39;Movies\u0026#39;, \u0026#39;Music\u0026#39;, \u0026#39;Pictures\u0026#39;, \u0026#39;Public\u0026#39;, \u0026#39;VirtualBox VMs\u0026#39;, \u0026#39;Workspace\u0026#39;, \u0026#39;XCode\u0026#39;]   for循环其实可以同时使用两个甚至多个变量，比如dict的items()可以同时迭代key和value：\n1 2 3 4 5 6 7  \u0026gt;\u0026gt;\u0026gt; d = {\u0026#39;x\u0026#39;: \u0026#39;A\u0026#39;, \u0026#39;y\u0026#39;: \u0026#39;B\u0026#39;, \u0026#39;z\u0026#39;: \u0026#39;C\u0026#39; } \u0026gt;\u0026gt;\u0026gt; for k, v in d.items(): ... print(k, \u0026#39;=\u0026#39;, v) ... y = B x = A z = C   因此，列表生成式也可以使用两个变量来生成list：\n1 2 3  \u0026gt;\u0026gt;\u0026gt; d = {\u0026#39;x\u0026#39;: \u0026#39;A\u0026#39;, \u0026#39;y\u0026#39;: \u0026#39;B\u0026#39;, \u0026#39;z\u0026#39;: \u0026#39;C\u0026#39; } \u0026gt;\u0026gt;\u0026gt; [k + \u0026#39;=\u0026#39; + v for k, v in d.items()] [\u0026#39;y=B\u0026#39;, \u0026#39;x=A\u0026#39;, \u0026#39;z=C\u0026#39;]   最后把一个list中所有的字符串变成小写：\n1 2 3  \u0026gt;\u0026gt;\u0026gt; L = [\u0026#39;Hello\u0026#39;, \u0026#39;World\u0026#39;, \u0026#39;IBM\u0026#39;, \u0026#39;Apple\u0026#39;] \u0026gt;\u0026gt;\u0026gt; [s.lower() for s in L] [\u0026#39;hello\u0026#39;, \u0026#39;world\u0026#39;, \u0026#39;ibm\u0026#39;, \u0026#39;apple\u0026#39;]   生成器 通过列表生成式，我们可以直接创建一个列表。但是，受到内存限制，列表容量肯定是有限的。而且，创建一个包含100万个元素的列表，不仅占用很大的存储空间，如果我们仅仅需要访问前面几个元素，那后面绝大多数元素占用的空间都白白浪费了。\n所以，如果列表元素可以按照某种算法推算出来，那我们是否可以在循环的过程中不断推算出后续的元素呢？这样就不必创建完整的list，从而节省大量的空间。在Python中，这种一边循环一边计算的机制，称为生成器：generator。\n要创建一个generator，有很多种方法。第一种方法很简单，只要把一个列表生成式的[]改成()，就创建了一个generator：\n1 2 3 4 5 6  \u0026gt;\u0026gt;\u0026gt; L = [x * x for x in range(10)] \u0026gt;\u0026gt;\u0026gt; L [0, 1, 4, 9, 16, 25, 36, 49, 64, 81] \u0026gt;\u0026gt;\u0026gt; g = (x * x for x in range(10)) \u0026gt;\u0026gt;\u0026gt; g \u0026lt;generator object \u0026lt;genexpr\u0026gt; at 0x1022ef630\u0026gt;   创建L和g的区别仅在于最外层的[]和()，L是一个list，而g是一个generator。\n我们可以直接打印出list的每一个元素，但我们怎么打印出generator的每一个元素呢？\n如果要一个一个打印出来，可以通过next()函数获得generator的下一个返回值：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  \u0026gt;\u0026gt;\u0026gt; next(g) 0 \u0026gt;\u0026gt;\u0026gt; next(g) 1 \u0026gt;\u0026gt;\u0026gt; next(g) 4 \u0026gt;\u0026gt;\u0026gt; next(g) 9 \u0026gt;\u0026gt;\u0026gt; next(g) 16 \u0026gt;\u0026gt;\u0026gt; next(g) 25 \u0026gt;\u0026gt;\u0026gt; next(g) 36 \u0026gt;\u0026gt;\u0026gt; next(g) 49 \u0026gt;\u0026gt;\u0026gt; next(g) 64 \u0026gt;\u0026gt;\u0026gt; next(g) 81 \u0026gt;\u0026gt;\u0026gt; next(g) Traceback (most recent call last): File \u0026#34;\u0026lt;stdin\u0026gt;\u0026#34;, line 1, in \u0026lt;module\u0026gt; StopIteration   我们讲过，generator保存的是算法，每次调用next(g)，就计算出g的下一个元素的值，直到计算到最后一个元素，没有更多的元素时，抛出StopIteration的错误。\n当然，上面这种不断调用next(g)实在是太变态了，正确的方法是使用for循环，因为generator也是可迭代对象：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  \u0026gt;\u0026gt;\u0026gt; g = (x * x for x in range(10)) \u0026gt;\u0026gt;\u0026gt; for n in g: ... print(n) ... 0 1 4 9 16 25 36 49 64 81   所以，我们创建了一个generator后，基本上永远不会调用next()，而是通过for循环来迭代它，并且不需要关心StopIteration的错误。\ngenerator非常强大。如果推算的算法比较复杂，用类似列表生成式的for循环无法实现的时候，还可以用函数来实现。\n比如，著名的斐波拉契数列（Fibonacci），除第一个和第二个数外，任意一个数都可由前两个数相加得到：\n1, 1, 2, 3, 5, 8, 13, 21, 34, \u0026hellip;\n斐波拉契数列用列表生成式写不出来，但是，用函数把它打印出来却很容易：\n1 2 3 4 5 6 7  def fib(max): n, a, b = 0, 0, 1 while n \u0026lt; max: print(b) a, b = b, a + b n = n + 1 return \u0026#39;done\u0026#39;   *注意*，赋值语句：\n1  a, b = b, a + b   相当于：\n1 2 3  t = (b, a + b) # t是一个tuple a = t[0] b = t[1]   但不必显式写出临时变量t就可以赋值。\n上面的函数可以输出斐波那契数列的前N个数：\n1 2 3 4 5 6 7 8  \u0026gt;\u0026gt;\u0026gt; fib(6) 1 1 2 3 5 8 \u0026#39;done\u0026#39;   仔细观察，可以看出，fib函数实际上是定义了斐波拉契数列的推算规则，可以从第一个元素开始，推算出后续任意的元素，这种逻辑其实非常类似generator。\n也就是说，上面的函数和generator仅一步之遥。要把fib函数变成generator，只需要把print(b)改为yield b就可以了：\n1 2 3 4 5 6 7  def fib(max): n, a, b = 0, 0, 1 while n \u0026lt; max: yield b a, b = b, a + b n = n + 1 return \u0026#39;done\u0026#39;   这就是定义generator的另一种方法。如果一个函数定义中包含yield关键字，那么这个函数就不再是一个普通函数，而是一个generator：\n1 2 3  \u0026gt;\u0026gt;\u0026gt; f = fib(6) \u0026gt;\u0026gt;\u0026gt; f \u0026lt;generator object fib at 0x104feaaa0\u0026gt;   这里，最难理解的就是generator和函数的执行流程不一样。函数是顺序执行，遇到return语句或者最后一行函数语句就返回。而变成generator的函数，在每次调用next()的时候执行，遇到yield语句返回，再次执行时从上次返回的yield语句处继续执行。\n举个简单的例子，定义一个generator，依次返回数字1，3，5：\n1 2 3 4 5 6 7  def odd(): print(\u0026#39;step 1\u0026#39;) yield 1 print(\u0026#39;step 2\u0026#39;) yield(3) print(\u0026#39;step 3\u0026#39;) yield(5)   调用该generator时，首先要生成一个generator对象，然后用next()函数不断获得下一个返回值：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  \u0026gt;\u0026gt;\u0026gt; o = odd() \u0026gt;\u0026gt;\u0026gt; next(o) step 1 1 \u0026gt;\u0026gt;\u0026gt; next(o) step 2 3 \u0026gt;\u0026gt;\u0026gt; next(o) step 3 5 \u0026gt;\u0026gt;\u0026gt; next(o) Traceback (most recent call last): File \u0026#34;\u0026lt;stdin\u0026gt;\u0026#34;, line 1, in \u0026lt;module\u0026gt; StopIteration   可以看到，odd不是普通函数，而是generator，在执行过程中，遇到yield就中断，下次又继续执行。执行3次yield后，已经没有yield可以执行了，所以，第4次调用next(o)就报错。\n回到fib的例子，我们在循环过程中不断调用yield，就会不断中断。当然要给循环设置一个条件来退出循环，不然就会产生一个无限数列出来。\n同样的，把函数改成generator后，我们基本上从来不会用next()来获取下一个返回值，而是直接使用for循环来迭代：\n1 2 3 4 5 6 7 8 9  \u0026gt;\u0026gt;\u0026gt; for n in fib(6): ... print(n) ... 1 1 2 3 5 8   但是用for循环调用generator时，发现拿不到generator的return语句的返回值。如果想要拿到返回值，必须捕获StopIteration错误，返回值包含在StopIteration的value中：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  \u0026gt;\u0026gt;\u0026gt; g = fib(6) \u0026gt;\u0026gt;\u0026gt; while True: ... try: ... x = next(g) ... print(\u0026#39;g:\u0026#39;, x) ... except StopIteration as e: ... print(\u0026#39;Generator return value:\u0026#39;, e.value) ... break ... g: 1 g: 1 g: 2 g: 3 g: 5 g: 8 Generator return value: done   迭代器 我们已经知道，可以直接作用于for循环的数据类型有以下几种：\n一类是集合数据类型，如list、tuple、dict、set、str等；\n一类是generator，包括生成器和带yield的generator function。\n这些可以直接作用于for循环的对象统称为可迭代对象：Iterable。\n可以使用isinstance()判断一个对象是否是Iterable对象：\n1 2 3 4 5 6 7 8 9 10 11  \u0026gt;\u0026gt;\u0026gt; from collections import Iterable \u0026gt;\u0026gt;\u0026gt; isinstance([], Iterable) True \u0026gt;\u0026gt;\u0026gt; isinstance({}, Iterable) True \u0026gt;\u0026gt;\u0026gt; isinstance(\u0026#39;abc\u0026#39;, Iterable) True \u0026gt;\u0026gt;\u0026gt; isinstance((x for x in range(10)), Iterable) True \u0026gt;\u0026gt;\u0026gt; isinstance(100, Iterable) False   而生成器不但可以作用于for循环，还可以被next()函数不断调用并返回下一个值，直到最后抛出StopIteration错误表示无法继续返回下一个值了。\n可以被next()函数调用并不断返回下一个值的对象称为迭代器：Iterator。\n可以使用isinstance()判断一个对象是否是Iterator对象：\n1 2 3 4 5 6 7 8 9  \u0026gt;\u0026gt;\u0026gt; from collections import Iterator \u0026gt;\u0026gt;\u0026gt; isinstance((x for x in range(10)), Iterator) True \u0026gt;\u0026gt;\u0026gt; isinstance([], Iterator) False \u0026gt;\u0026gt;\u0026gt; isinstance({}, Iterator) False \u0026gt;\u0026gt;\u0026gt; isinstance(\u0026#39;abc\u0026#39;, Iterator) False   生成器都是Iterator对象，但list、dict、str虽然是Iterable，却不是Iterator。\n把list、dict、str等Iterable变成Iterator可以使用iter()函数：\n1 2 3 4  \u0026gt;\u0026gt;\u0026gt; isinstance(iter([]), Iterator) True \u0026gt;\u0026gt;\u0026gt; isinstance(iter(\u0026#39;abc\u0026#39;), Iterator) True   你可能会问，为什么list、dict、str等数据类型不是Iterator？\n这是因为Python的Iterator对象表示的是一个数据流，Iterator对象可以被next()函数调用并不断返回下一个数据，直到没有数据时抛出StopIteration错误。可以把这个数据流看做是一个有序序列，但我们却不能提前知道序列的长度，只能不断通过next()函数实现按需计算下一个数据，所以Iterator的计算是惰性的，只有在需要返回下一个数据时它才会计算。\nIterator甚至可以表示一个无限大的数据流，例如全体自然数。而使用list是永远不可能存储全体自然数的。\n"
},
{
	"uri": "http://yu-zhang-1985.github.io/en/tags/",
	"title": "Tags",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "http://yu-zhang-1985.github.io/en/posts/python%E5%AD%A6%E4%B9%A01/",
	"title": "Python学习1",
	"tags": ["Python"],
	"categories": [],
	"series": [],
	"description": "",
	"content": " Python 学习 1 Coding 1  # -*- coding:utf-8 -*-   告诉python解释器，按照UTF-8编码读取源代码\nDict  dict的key必须是不可变对象。  这是因为dict根据key来计算value的存储位置，如果每次计算相同的key得出的结果不同，那dict内部就完全混乱了。这个通过key计算位置的算法称为哈希算法（Hash）。\n要保证hash的正确性，作为key的对象就不能变。在Python中，字符串、整数等都是不可变的，因此，可以放心地作为key。而list是可变的，就不能作为key。\nSet  set和dict类似，也是一组key的集合，但不存储value。由于key不能重复，所以，在set中，没有重复的key。  要创建一个set，需要提供一个list作为输入集合：\n1 2 3  \u0026gt;\u0026gt;\u0026gt; s = set([1, 2, 3]) \u0026gt;\u0026gt;\u0026gt; s {1, 2, 3}    通过add(key)方法可以添加元素到set中，可以重复添加，但不会有效果.\n 通过remove(key)方法可以删除元素.\n set和dict的唯一区别仅在于没有存储对应的value，但是，set的原理和dict一样，所以，同样不可以放入可变对象，因为无法判断两个可变对象是否相等，也就无法保证set内部“不会有重复元素”。\n  不可变对象  对于不变对象来说，调用对象自身的任意方法，也不会改变该对象自身的内容。相反，这些方法会创建新的对象并返回，这样，就保证了不可变对象本身永远是不可变的  函数  可以直接从Python的官方网站查看文档：http://docs.python.org/3/library/functions.html#abs  也可以在交互式命令行通过help(abs)查看abs函数的帮助信息。\n 在Python中，定义一个函数要使用def语句，依次写出函数名、括号、括号中的参数和冒号:，然后，在缩进块中编写函数体，函数的返回值用return语句返回。 Python的函数返回多值其实就是返回一个tuple。\n 定义默认参数要牢记一点：默认参数必须指向不变对象！\n  为什么要设计str、None这样的不变对象呢？因为不变对象一旦创建，对象内部的数据就不能修改，这样就减少了由于修改数据导致的错误。此外，由于对象不变，多任务环境下同时读取对象不需要加锁，同时读一点问题都没有。我们在编写程序时，如果可以设计一个不变对象，那就尽量设计成不变对象。\n Python允许你在list或tuple前面加一个*号，把list或tuple的元素变成可变参数传进去：\n1 2 3  \u0026gt;\u0026gt;\u0026gt; nums = [1, 2, 3] \u0026gt;\u0026gt;\u0026gt; calc(*nums) 14   关键字参数\n  可变参数允许你传入0个或任意个参数，这些可变参数在函数调用时自动组装为一个tuple。而关键字参数允许你传入0个或任意个含参数名的参数，这些关键字参数在函数内部自动组装为一个dict。请看示例：\n1 2  def person(name, age, **kw): print(\u0026#39;name:\u0026#39;, name, \u0026#39;age:\u0026#39;, age, \u0026#39;other:\u0026#39;, kw)   和可变参数类似，也可以先组装出一个dict，然后，把该dict转换为关键字参数传进去：\n1 2 3  \u0026gt;\u0026gt;\u0026gt; extra = {\u0026#39;city\u0026#39;: \u0026#39;Beijing\u0026#39;, \u0026#39;job\u0026#39;: \u0026#39;Engineer\u0026#39;} \u0026gt;\u0026gt;\u0026gt; person(\u0026#39;Jack\u0026#39;, 24, city=extra[\u0026#39;city\u0026#39;], job=extra[\u0026#39;job\u0026#39;]) name: Jack age: 24 other: {\u0026#39;city\u0026#39;: \u0026#39;Beijing\u0026#39;, \u0026#39;job\u0026#39;: \u0026#39;Engineer\u0026#39;}   当然，上面复杂的调用可以用简化的写法：\n1 2 3  \u0026gt;\u0026gt;\u0026gt; extra = {\u0026#39;city\u0026#39;: \u0026#39;Beijing\u0026#39;, \u0026#39;job\u0026#39;: \u0026#39;Engineer\u0026#39;} \u0026gt;\u0026gt;\u0026gt; person(\u0026#39;Jack\u0026#39;, 24, **extra) name: Jack age: 24 other: {\u0026#39;city\u0026#39;: \u0026#39;Beijing\u0026#39;, \u0026#39;job\u0026#39;: \u0026#39;Engineer\u0026#39;}   **extra表示把extra这个dict的所有key-value用关键字参数传入到函数的**kw参数，kw将获得一个dict，注意kw获得的dict是extra的一份拷贝，对kw的改动不会影响到函数外的extra。\n 如果要限制关键字参数的名字，就可以用命名关键字参数，例如，只接收city和job作为关键字参数。这种方式定义的函数如下：\n1 2  def person(name, age, *, city, job): print(name, age, city, job)    和关键字参数**kw不同，命名关键字参数需要一个特殊分隔符*，*后面的参数被视为命名关键字参数。\n调用方式如下：\n1 2  \u0026gt;\u0026gt;\u0026gt; person(\u0026#39;Jack\u0026#39;, 24, city=\u0026#39;Beijing\u0026#39;, job=\u0026#39;Engineer\u0026#39;) Jack 24 Beijing Engineer   如果函数定义中已经有了一个可变参数，后面跟着的命名关键字参数就不再需要一个特殊分隔符*了：\n1 2  def person(name, age, *args, city, job): print(name, age, args, city, job)   命名关键字参数必须传入参数名，这和位置参数不同。如果没有传入参数名，调用将报错：\n1 2 3 4  \u0026gt;\u0026gt;\u0026gt; person(\u0026#39;Jack\u0026#39;, 24, \u0026#39;Beijing\u0026#39;, \u0026#39;Engineer\u0026#39;) Traceback (most recent call last): File \u0026#34;\u0026lt;stdin\u0026gt;\u0026#34;, line 1, in \u0026lt;module\u0026gt; TypeError: person() takes 2 positional arguments but 4 were given   由于调用时缺少参数名city和job，Python解释器把这4个参数均视为位置参数，但person()函数仅接受2个位置参数。\n命名关键字参数可以有缺省值，从而简化调用：\n1 2  def person(name, age, *, city=\u0026#39;Beijing\u0026#39;, job): print(name, age, city, job)   由于命名关键字参数city具有默认值，调用时，可不传入city参数：\n1 2  \u0026gt;\u0026gt;\u0026gt; person(\u0026#39;Jack\u0026#39;, 24, job=\u0026#39;Engineer\u0026#39;) Jack 24 Beijing Engineer   使用命名关键字参数时，要特别注意，如果没有可变参数，就必须加一个*作为特殊分隔符。如果缺少*，Python解释器将无法识别位置参数和命名关键字参数：\n1 2 3  def person(name, age, city, job): # 缺少 *，city和job被视为位置参数 pass    参数组合  在Python中定义函数，可以用必选参数、默认参数、可变参数、关键字参数和命名关键字参数，这5种参数都可以组合使用。但是请注意，参数定义的顺序必须是：必选参数、默认参数、可变参数、命名关键字参数和关键字参数。\n比如定义一个函数，包含上述若干种参数：\n1 2 3 4 5  def f1(a, b, c=0, *args, **kw): print(\u0026#39;a =\u0026#39;, a, \u0026#39;b =\u0026#39;, b, \u0026#39;c =\u0026#39;, c, \u0026#39;args =\u0026#39;, args, \u0026#39;kw =\u0026#39;, kw) def f2(a, b, c=0, *, d, **kw): print(\u0026#39;a =\u0026#39;, a, \u0026#39;b =\u0026#39;, b, \u0026#39;c =\u0026#39;, c, \u0026#39;d =\u0026#39;, d, \u0026#39;kw =\u0026#39;, kw)   对于任意函数，都可以通过类似func(*args, **kw)的形式调用它，无论它的参数是如何定义的。\n虽然可以组合多达5种参数，但不要同时使用太多的组合，否则函数接口的可理解性很差。\n 递归函数  在函数内部，可以调用其他函数。如果一个函数在内部调用自身本身，这个函数就是递归函数。\n举个例子，我们来计算阶乘n! = 1 x 2 x 3 x ... x n，用函数fact(n)表示，可以看出：\nfact(n) = n! = 1 x 2 x 3 x \u0026hellip; x (n-1) x n = (n-1)! x n = fact(n-1) x n\n所以，fact(n)可以表示为n x fact(n-1)，只有n=1时需要特殊处理。\n于是，fact(n)用递归的方式写出来就是：\n1 2 3 4  def fact(n): if n==1: return 1 return n * fact(n - 1)   上面就是一个递归函数。\n递归函数的优点是定义简单，逻辑清晰。理论上，所有的递归函数都可以写成循环的方式，但循环的逻辑不如递归清晰。\n使用递归函数需要注意防止栈溢出。在计算机中，函数调用是通过栈（stack）这种数据结构实现的，每当进入一个函数调用，栈就会加一层栈帧，每当函数返回，栈就会减一层栈帧。由于栈的大小不是无限的，所以，递归调用的次数过多，会导致栈溢出。\n尾递归是指，在函数返回的时候，调用自身本身，并且，return语句不能包含表达式。这样，编译器或者解释器就可以把尾递归做优化，使递归本身无论调用多少次，都只占用一个栈帧，不会出现栈溢出的情况。\n上面的fact(n)函数由于return n * fact(n - 1)引入了乘法表达式，所以就不是尾递归了。要改成尾递归方式，需要多一点代码，主要是要把每一步的乘积传入到递归函数中：\n1 2 3 4 5 6 7  def fact(n): return fact_iter(n, 1) def fact_iter(num, product): if num == 1: return product return fact_iter(num - 1, num * product)   可以看到，return fact_iter(num - 1, num * product)仅返回递归函数本身，num - 1和num * product在函数调用前就会被计算，不影响函数调用。\n"
},
{
	"uri": "http://yu-zhang-1985.github.io/en/categories/",
	"title": "Categories",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "http://yu-zhang-1985.github.io/en/gallery/",
	"title": "Galleries",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "http://yu-zhang-1985.github.io/en/gallery/mygallery/",
	"title": "Gallery",
	"tags": [""],
	"categories": [],
	"series": [""],
	"description": "",
	"content": ""
},
{
	"uri": "http://yu-zhang-1985.github.io/en/series/",
	"title": "Series",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
}]